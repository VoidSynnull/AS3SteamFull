package game.scene.template
{

import flash.display.DisplayObjectContainer;
import flash.utils.Dictionary;

import ash.core.Entity;

import engine.components.Spatial;
import engine.group.Group;
import engine.group.Scene;

import game.components.entity.character.Skin;
import game.components.motion.Proximity;
import game.data.character.LookConverter;
import game.data.character.LookData;
import game.data.game.GameEvent;
import game.data.photos.PhotoData;
import game.managers.PhotoManager;
import game.systems.SystemPriorities;
import game.systems.motion.ProximitySystem;
import game.ui.hud.Hud;
import game.util.DataUtils;
import game.util.SkinUtils;

/**
 * Group that manages scene photos.
 * Sets up from XML describing photos within scene, generally the 'photos.xml'.
 */
public class PhotoGroup extends Group
{

	public static const GROUP_ID:String = "photoGroup";
	public static const PROXIMITY_ID_PREFIX:String = 'PhotoTrigger';

	private var _photoDatas:Vector.<PhotoData>;		// all PhotoData for given scene
	private var _photoTriggersRemaining:Dictionary;	// keys are event IDs, values are photo IDs
	
	/** Used to manually specify LookData used for photos */
	public var photoLook:LookData;
	/** Used to manually specify Entity used to retrieve LookData for photos */
	public var photoEntity:Entity;

	public function PhotoGroup()
	{
		super();
		this.id = GROUP_ID;
		_photoTriggersRemaining = new Dictionary();
	}

	public function setupScene(scene:Scene, xml:XML, hitContainer:DisplayObjectContainer):void
	{			
		// add it as a child group to give it access to systemManager.
		scene.addChildGroup(this);
		
		if (addPhotos(xml)) 
		{
			// subscribe to a stream of signals generated by the GameEventManager, 
			// checks against triggered events these to see if any match photos
			shellApi.eventTriggered.add(onEventTriggered);
		}
	}
	
	/**
	 * Add all unearned photos to scene based on the scene's 'photos.xml' data file.
	 * @return A count of photos actually added to the scene.
	 */
	private function addPhotos(xml:XML):uint
	{
		var numAdded:uint = 0;
		if(xml != null)
		{
			_photoDatas = new Vector.<PhotoData>();
			var photoManager:PhotoManager = shellApi.getManager(PhotoManager) as PhotoManager;
			if( photoManager )
			{
				for each (var photoElement:XML in xml.photo) 
				{
					// check if photo has already been taken, if not add to scene
					var photoData:PhotoData = new PhotoData(photoElement);
					if( !photoManager.checkIsTaken( photoData.id, shellApi.island) )
					{
						trace("PhotoGroup::addPhotos(): adding photoData", photoData);
						addScenePhoto(photoData);
						numAdded++;
					} 
					else 
					{
						trace("PhotoGroup::addPhotos(): skipping over photo ID", photoData.id, "since it has already been snapped");
					}
					_photoDatas.push(photoData); 
				}
			}
		}
		return numAdded;
	}
	
	/**
	 * Checks if photo should be taken
	 * @param eventName - name of event associated with photo
	 * @return - returns true if event match valid photoId & photo has not already been taken
	 */
	public function shouldTakePhotoByEvent(eventName:String):Boolean 
	{
		// check sif photo has already been taken
		var photoMananager:PhotoManager = shellApi.getManager(PhotoManager) as PhotoManager;
		if( photoMananager )
		{
			var photoId:String = this.photoIDByEvent(eventName);
			// check validity
			if( DataUtils.validString(photoId) )
			{
				// check if already taken
				return !photoMananager.checkIsTaken( photoId, shellApi.island);
			}
		}
		return false;
	}
	
	/**
	 * Checks if photo should be taken
	 * @param eventName - name of event associated with photo
	 * @return - returns true if event match valid photoId & photo has not already been taken
	 */
	public function shouldTakePhoto(photoId:String):Boolean 
	{
		// check sif photo has already been taken
		var photoMananager:PhotoManager = shellApi.getManager(PhotoManager) as PhotoManager;
		if( photoMananager )
		{
			// check validity
			if( this.checkValidPhoto(photoId) )
			{
				// check if already taken
				return !photoMananager.checkIsTaken( photoId, shellApi.island);
			}
		}
		return false;
	}

	/**
	 * Returns photo id that matches event
	 * @param eventName
	 * @return 
	 */
	public function photoIDByEvent(eventName:String):String 
	{
		return _photoTriggersRemaining[eventName];
	}
	
	/**
	 * Checks if photoId is valid for current scene 
	 * @param photoId
	 * @return 
	 */
	public function checkValidPhoto( photoId:String ):Boolean
	{
		if( _photoDatas )
		{
			for (var i:int = 0; i < _photoDatas.length; i++) 
			{
				if( _photoDatas[i].id == photoId )
				{
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Handler for shell api events dispatch, takes photo if event is found in list of photo triggers.
	 * @param eventName
	 * @param makeCurrent
	 * @param init
	 * @param removeEvent
	 * @param completeHandler
	 */
	public function onEventTriggered(eventName:String, makeCurrent:Boolean=true, init:Boolean=false, removeEvent:String=null, completeHandler:Function = null):void 
	{
		takePhotoByEvent( eventName, completeHandler );
	}
	
	/**
	 * Takes photo if event is found in list of photo triggers.
	 * @param eventName
	 * @param completeHandler
	 */
	public function takePhotoByEvent(eventName:String, callback:Function = null, forceCallback:Boolean = true, lookData:LookData = null):Boolean
	{
		var photoID:String = _photoTriggersRemaining[eventName];
		if ( DataUtils.validString(photoID) ) 
		{
			delete _photoTriggersRemaining[eventName];
			return takePhoto(photoID, super.shellApi.island, callback, forceCallback, lookData);
		}
		if( forceCallback && ( callback != null ) )  { callback(); }
		return false;
	}

	/**
	 * Take a photo, if it hasn't already been taken.
	 * @param photoId
	 * @param setId
	 * @param completeHandler - if photo is taken completeHandlerwill be called once UI elemnet has finished
	 * @param lookData
	 * @return - returns true if photo is being taken along with an accomanying UI elment
	 */
	public function takePhoto(photoId:String, setId = null, callback:Function = null, forceCallback:Boolean = true, lookData:LookData = null):Boolean
	{
		// take photo, if taken trigger UI
		if( this.checkValidPhoto(photoId) )
		{
			if( setId == null )	{ setId = super.shellApi.island; }
			if( lookData == null ) { lookData = this.getPhotoLook(); }
			// attempt to take photo, if successful then trigger the photo display
			if( (shellApi.getManager(PhotoManager) as PhotoManager).take(photoId, setId, lookData) )
			{
				displayPhotoTaken(callback);
				return true;
			}
		}

		if( forceCallback && ( callback != null ) )  { callback(); }
		return false;
	}
	
	/**
	 * Trigger the visual for a photo being taken, this currently resides in huh
	 * TODO :: this should not rely on hud but be standalone, so it can be called anywhere (within a popup for example) - bard
	 * Want to remove photo dispaly from hud and have it managed within PhotoGroup
	 * @param callback
	 */
	private function displayPhotoTaken(callback:Function = null):void
	{
		// trigger photo notification
		// 
		var uiGroup:SceneUIGroup = super.getGroupById(SceneUIGroup.GROUP_ID) as SceneUIGroup;
		// shouldn't be null
		if (uiGroup != null)
		{
			(uiGroup.hud as Hud).showPhotoNotification( callback );
		}
		else
		{
			trace( this," :: Error :: takePhoto : SceneUIGroup should be available, so that photo notification can be displayed." );  
			if( callback != null )	{ callback(); }			
		}
	}
	
	/**
	 * Get LookData to be used by 
	 * @return 
	 */
	private function getPhotoLook():LookData
	{
		var lookData:LookData = this.photoLook;
		if( lookData == null )
		{
			var photoChar:Entity = ( this.photoEntity != null ) ? this.photoEntity : shellApi.player;
			if ( photoChar && photoChar.get(Skin)) 
			{
				lookData = SkinUtils.getLook( photoChar, false );
			} 
			else 
			{
				lookData = new LookConverter().lookDataFromPlayerLook( shellApi.profileManager.active.look );
			}
		}
		return lookData;
	}

	/**
	 * Add photo trigger for scene.
	 * Photos don't necessarily need a trigger, they can be called manually if that is easier
	 * @param data
	 */
	private function addScenePhoto(data:PhotoData):void 
	{
		switch (data.trigger) 
		{
			case PhotoData.TRIGGER_LOCATION:
				// TODO :: This will override any other existing Proxity component, coudl be a problem. - bard
				shellApi.player.add(createProximityTrigger(data, onProximityEntered));
				addSystem(new ProximitySystem(), SystemPriorities.checkCollisions);
				break;
			
			case PhotoData.TRIGGER_EVENT:
				_photoTriggersRemaining[data.params.eventName] = data.id;
				break;
			
			case PhotoData.TRIGGER_ITEM:
				trace("PhotoGroup::addScenePhoto() adds photo", data.id, "for item", data.params.itemID);
				_photoTriggersRemaining[GameEvent.GOT_ITEM + data.params.itemID] = data.id;
				break;
		}
	}
	
	//////////////////////////// PROXIMITY PHOTOS ////////////////////////////

	private function createProximityTrigger(data:PhotoData, proximityHandler:Function):Proximity 
	{
		var proximity:Proximity = new Proximity(data.params.proximity, new Spatial(data.params.xpos, data.params.ypos));
		proximity.id = PROXIMITY_ID_PREFIX + data.id;
		proximity.entered.addOnce(proximityHandler);

		return proximity;
	}

	private function onProximityEntered(occupant:Entity):void 
	{
		if (occupant == shellApi.player) 
		{
			var proximity:Proximity = occupant.get(Proximity) as Proximity;
			// derive photo id from Proximity id
			var photoID:String = proximity.id;
			if (0 == photoID.indexOf(PROXIMITY_ID_PREFIX)) 
			{
				photoID = photoID.substr(PROXIMITY_ID_PREFIX.length);
			}
			takePhoto(photoID);
		}
	}
}

}
